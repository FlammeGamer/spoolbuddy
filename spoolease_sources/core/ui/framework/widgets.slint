import { ListView } from "std-widgets.slint";

export component MyText inherits Text {
    font-size: 20px;
    color: black;
}

export enum ButtonType {
  Standard,
  PushButton,
  RadioButton,
}

export component MyButton inherits Rectangle {
    callback pressed;
    callback released;
    in property <ButtonType> type: ButtonType.Standard;
    in-out property <string> text;
    in property <length> text-padding;
    in property <bool> enabled: true;
    in-out property <bool> pushed: false;
    in property <color> pushed-background: lightgreen;
    in property <color> released-background: white;
    in property <color> text-color: black; 
    in property <TextHorizontalAlignment> horizontal-alignment: center;
    callback clicked;
    background: (type == ButtonType.Standard) ? (enabled ? @linear-gradient(20deg, #3559E0 0%, #c2cdf6 100%) : @linear-gradient(20deg, #5C5C5C 0%, #CFCFCF 100%)) : ((enabled && area.pressed) || pushed ? pushed-background : released-background);
    Text {
        x: text-padding;
        width: parent.width - text-padding * 2;
        horizontal-alignment: root.horizontal-alignment;
        text: root.text;
        font-size: 20px;
        font-weight: 400 + (enabled && area.pressed && type == ButtonType.Standard ? 500 : 0);
        wrap: word-wrap;
        color: enabled ? text-color : #666666;
    }

    area := TouchArea {
        width: parent.width;
        height: parent.height;
        changed pressed => {
            if self.pressed == true && type == ButtonType.PushButton {
                root.pushed = !root.pushed;
            }
            if self.pressed == true {
                root.pressed();
            } else {
                root.released();
            }
        }
        clicked => {
            if enabled {
                root.clicked();
            }
        }
    }

    Rectangle {
        // to add the border - slint software renderer doen't do gradents with border
        width: root.width;
        height: root.height;
        border-color: black;
        border-width: 1px + ((enabled && area.pressed) || pushed ? 2px : 0px);
    }
}

export component Title inherits Rectangle {
    in-out property <string> text;
    in-out property <string> text2;
    height: 40px;
    background: green.brighter(1.0);
    in-out property <color> text-color: black;
    border-color: black;
    border-width: 1px;
    in property <TextHorizontalAlignment> horizontal-alignment: center;
    in property <TextHorizontalAlignment> horizontal-alignment2: center;
    title-timer := Timer {
        property <int> text-index: 0;
        interval: 4s;
        running: text2 != "";
        triggered() => {
            text-index = 1 - text-index;
        }
    }

    Text {
        width: root.width;
        vertical-alignment: center;
        horizontal-alignment: title-timer.text-index == 0 ? horizontal-alignment : horizontal-alignment2;
        height: root.height;
        text: title-timer.text-index == 0 ? text : text2;
        color: text-color;
        font-size: 20px;
    }
}

export struct SelectorOption {
    id: int,
    text: string,
}

// Only for compatibility with Option-1 of Selector
export struct SelectorOptionsList {
    id: int,
    title: string,
    options: [SelectorOption],
}

export component Selector inherits Rectangle {
    public function jump-to(position: int) {
        list.set-target(position * option-height, "gesture");
    }
    callback selected(text: string, pos-in-list: int, id: int);
    callback filter-clicked();
    in-out property <[SelectorOption]> options-list;
    changed options-list => {
        list.set-target(0, "change-data");
    }
    in property <length> option-height: 56px;
    in property <length> page-buttons-height: 56px;
    in property <length> filter-button-height: 0px; // disabled by default
    in property <length> thumb-height: 56px;
    in property <length> scrollbar-width: 56px;
    in property <TextHorizontalAlignment> option-alignment: center;
    in-out property <string> selector-title;
    in property <length> scroll-px-per-sec: 320px;
    background: white;
    VerticalLayout {
        if root.selector-title != "": title := Title {
            z: 1;
            text: root.selector-title;
        }

        HorizontalLayout {

            Rectangle {
                clip: true;
                sgr := SwipeGestureHandler {
                    width: parent.width;
                    height: parent.height;
                    handle-swipe-up: true;
                    handle-swipe-down: true;
                    handle-swipe-left: false;
                    handle-swipe-right: false;
                    swiped => {
                        if self.handle-swipe-down && self.current-position.y > self.pressed-position.y + (self.height / 8) {
                            // swipe down 
                            list.set-target(list.viewport-y - list.height, "gesture");
                        } else if self.handle-swipe-up && self.current-position.y < self.pressed-position.y - (self.height / 8) {
                            if list.preferred-height > list.height {
                                list.set-target(list.viewport-y + list.height, "gesture");
                            }
                        }
                    }
                    list := VerticalLayout {
                        property <length> viewport-height: root.options-list.length * option-height;
                        property <length> viewport-y: target-viewport-y;
                        property <length> target-viewport-y;
                        property <int> num-items-to-render: floor(list.height / option-height) + 1;
                        changed target-viewport-y => {
                            if viewport-y == target-viewport-y {
                                self.moving = false;
                                self.move-trigger = "";
                            }
                        }
                        animate viewport-y {
                            duration: 1s;
                            // duration: viewport-height / 400px * 1s; // panics
                            easing: ease-in-out;
                        }
                        property <int> first-item: floor(viewport-y / option-height);

                        property <length> target-y: 0px;
                        function set-target(target-y: length, move-trigger: string) {
                            set-target-inner(round(target-y / 1px) * 1px, move-trigger);
                        }
                        function set-target-inner(target-y: length, move-trigger: string) {
                            if (target-y < 0px ? 0px : target-y > viewport-height - list.height ? viewport-height - list.height : target-y) != target-viewport-y {
                                target-viewport-y = target-y < 0px ? 0px : target-y > viewport-height - list.height ? viewport-height - list.height : target-y;
                                self.moving = true;
                                self.move-trigger = move-trigger;
                            }
                        }
                        in-out property <bool> moving: false;
                        in-out property <string> move-trigger: "";

                        y: - mod( viewport-y, option-height);
                        // y: - mod( round(viewport-y/1px)*1px, option-height );
                        for i in num-items-to-render: Window {
                        // for i in 170: Window { // to test rendering of all items (but not components)
                            height: option-height;
                            if self.y > -self.height && self.y <= list.height && root.options-list[first-item + i].id < 0: Rectangle {
                                background: lightskyblue;
                                border-color: black;
                                border-width: 1px;
                                Text {
                                    text: root.options-list[first-item + i].text;
                                    font-size: 20px;
                                }
                            }

                            if self.y > -self.height && self.y <= list.height && root.options-list[first-item + i].id >= 0: MyButton {
                                text-padding: 5px;
                                horizontal-alignment: root.option-alignment;
                                text: root.options-list[first-item + i].text;
                                height: option-height;
                                width: parent.width;
                                clicked => {
                                    root.selected(self.text, first-item + i, root.options-list[first-item + i].id);
                                }
                            }
                        }
                    }
                }

                ta := TouchArea {
                    width: parent.width;
                    height: parent.height;
                    enabled: list.target-viewport-y != list.viewport-y;
                    clicked => {
                        list.target-viewport-y = list.viewport-y;
                    }
                }
            }

            VerticalLayout {
                if filter-button-height != 0: filter := MyButton {
                    text: "ABC";
                    height: filter-button-height;
                    clicked => {
                        filter-clicked()
                    }
                }

                page-up := Rectangle {
                    height: page-buttons-height;
                    background: green;
                    Text {
                        width: parent.width;
                        height: parent.height;
                        font-size: 20px;
                        vertical-alignment: center;
                        horizontal-alignment: center;
                        text: "▲";
                    }

                    TouchArea {
                        height: parent.height;
                        width: parent.width;
                        clicked => {
                            // list.target-viewport-y = max(list.target-viewport-y - list.height, 0); 
                            list.set-target(list.target-viewport-y - option-height, "page-btn");
                        }
                    }
                }

                scrollbar := Rectangle {
                    property <length> thumb-range: self.height - thumb.height;
                    background: black;
                    property <length> thumb_y_during_drag;
                    border-color: black;
                    border-width: 1px;
                    width: scrollbar-width;
                    thumb := Rectangle {
                        y: thumb-touch.pressed ? thumb_y_during_drag : (list.moving && list.move-trigger == "thumb") ? thumb_y_during_drag : list.viewport-y / (list.viewport-height - list.height) * thumb-range;
                        height: thumb-height;
                        background: lime;
                        Text {
                            font-size: 20px;
                            text: "▲\n▼";
                        }
                    }

                    thumb-touch := TouchArea {
                        property <length> prev-update-y: -10px;
                        height: parent.height;
                        // Remarked because hurts the confition in the move to filter out small moves
                        // changed pressed => {
                        //     if list.preferred-height <= list.height {
                        //         return;
                        //     }
                        //     thumb_y_during_drag = min(max(self.mouse-y - thumb.height / 2, 0), scrollbar.height - thumb.height);
                        //     list.set-target(thumb_y_during_drag / thumb-range * (list.viewport-height - list.height), "thumb");
                        // }
                        clicked => { // after click and release (so once after both take place)
                            if list.viewport-height <= list.height {
                                return;
                            }
                            thumb_y_during_drag = (list.target-viewport-y / (list.viewport-height - list.height)) * thumb-range;
                        }
                        moved => {
                            if list.viewport-height <= list.height {
                                return;
                            }
                            thumb_y_during_drag = min(max(self.mouse-y - thumb.height / 2, 0), scrollbar.height - thumb.height);
                            // if abs(prev-update-y - self.mouse-y) > 10px {
                                list.set-target(thumb_y_during_drag / thumb-range * (list.viewport-height - list.height), "thumb");
                            self.prev-update-y = self.mouse-y;
                            thumb_y_during_drag = (list.target-viewport-y / (list.viewport-height - list.height)) * thumb-range;
                            // }
                        }
                    }
                }

                page-down := Rectangle {
                    height: page-up.height;
                    background: page-up.background;
                    Text {
                        width: parent.width;
                        height: parent.height;
                        font-size: 20px;
                        vertical-alignment: center;
                        horizontal-alignment: center;
                        text: "▼";
                    }

                    TouchArea {
                        height: parent.height;
                        width: parent.width;
                        clicked => {
                            // list.target-viewport-y = min(list.target-viewport-y + list.height, list.viewport-height - list.height); 
                            list.set-target(list.target-viewport-y + option-height, "page-btn");
                        }
                    }
                }
            }
        }
    }
}

export component LeftTab inherits Rectangle {
    in property <length> buttons-height: 56px;
    callback botom-tab-pressed;
    in-out property <int> selected-index: 0;
    out property <string> selected-text: tabs[selected-index];
    in property <[string]> tabs;
    in property <string> bottom-tab;

    background: white;
    width: 56px; // default width
    VerticalLayout {
        alignment: space-between;
        VerticalLayout {
            for tab[index] in tabs: MyButton {
                height: buttons-height;
                text: tab;
                pushed: root.selected-index == index;
                clicked => {
                    root.selected-index = index;
                }
            }
        }

        if bottom-tab != "": MyButton {
            height: 56px;
            text: bottom-tab;
            clicked => {
                root.botom-tab-pressed();
            }
        }
    }

    Rectangle {
        width: root.width;
        height: root.height;
        border-color: black;
        border-width: 1px;
    }
}

export component HorizontalSelector inherits Window {
    in property <brush> selected-color: lightgreen;
    in property <brush> unselected-color: lightgrey;
    in property <length> buttons-width: self.height;
    in property <length> min-button-width: 100px;
    in property <[string]> options;
    in property <int> default-option-index;
    in-out property <int> selected-option-index: default-option-index;
    out property <string> selected-option: options[selected-option-index];
    in-out property <int> centerd-option-index: default-option-index;

    left-arrow := MyButton {
        x: 0px;
        height: parent.height;
        width: buttons-width;
        text: "◀";
        clicked => {
            centerd-option-index = max(0, centerd-option-index - 1);
        }
    }

    Rectangle {
        clip: true;
        x: left-arrow.x + left-arrow.width;
        height: parent.height;
        width: right-arrow.x - self.x;
        property <length> button-width: max(self.width / options.length, min-button-width);
        border-color: black;
        border-width: 1px;
        background: unselected-color;

        Rectangle { // Add thicker borders on the sides only
           x: main.x - 1px;
            width: main.max-width + 2px;
            height: main.height;
            border-color: black;
            border-width: 1px;
            TouchArea {
              // to not pass press events below
           }
        }

        main := HorizontalLayout {
            x: - centerd-option-index * button-width + (self.width - button-width) / 2;
            animate x { duration: 250ms; }
            for option[index] in options: Rectangle {
                height: parent.height;
                width: button-width;
                background: option == selected-option ? selected-color : unselected-color;
                border-color: black;
                border-width: 1px;
                MyText {
                    text: option;
                    color: option == selected-option ? black : gray;
                }

                TouchArea {
                    clicked => {
                        selected-option-index = index;
                        centerd-option-index = index;
                    }
                }
            }
        }
    }

    right-arrow := MyButton {
        x: parent.width - self.width;
        height: parent.height;
        width: buttons-width;
        text: "▶";
        clicked => {
            centerd-option-index = min(centerd-option-index + 1, options.length - 1);
        }
    }
}

export component WizardButtons inherits HorizontalLayout {
    callback next-clicked;
    callback back-clicked;
    callback cancel-clicked;
    in-out property <string> next-text: "";
    in-out property <string> cancel-text: "";
    in-out property <bool> back-enabled: false;
    in-out property <bool> next-enabled: false;
    in-out property <bool> cancel-enabled: true;
    in-out property <bool> last-page: false;

    height: 56px;
    MyButton {
        text: "◀ Back";
        clicked => {
            back-clicked();
        }
        enabled: back-enabled;
    }

    MyButton {
        text: next-text == "" ? (last-page ? "✓ Finish" : "Next ▶") : next-text;
        enabled: next-enabled;
        clicked => {
            next-clicked();
        }
    }

    MyButton {
        text: cancel-text == "" ? "× Cancel" : cancel-text;
        enabled: cancel-enabled;
        clicked => {
            cancel-clicked();
        }
    }
}
