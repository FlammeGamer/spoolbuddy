import { FrameworkBackend, FrameworkState } from "framework/framework.slint";
import { MyButton } from "framework/widgets.slint";
import { AppConsts, AppBackend, AppState, StatusType, ControlState, SpoolScaleState, SpoolStagingState } from "app.slint";
import { Utils } from "utils.slint";
import { SpoolStaging } from "spoolstaging.slint";


export component ControlPanelBase inherits HorizontalLayout {
    in-out property <[string]> message-lines;
    in-out property <StatusType> message-type: StatusType.Normal;
    in-out property <color> message-color: black;
    in-out property <string> button1-text;
    in-out property <string> button2-text;
    callback clicked1;
    callback timeout-clicked1;
    callback manual-clicked1;
    callback clicked2;
    callback timeout-clicked2;
    callback manual-clicked2;
    in-out property <int> button1-timeout: 0;
    changed button1-timeout => {
        if button1-timeout > 0 {
            button1-timer-count = button1-timeout;
        }
    }
    in-out property <int> button2-timeout: 0;
    changed button2-timeout => {
        if button2-timeout > 0 {
            button2-timer-count = button2-timeout;
        }
    }
    in-out property <length> button-width;
    in-out property <length> text-border-width: 1px;

    in-out property <int> button1-timer-count: button1-timeout;
    button1-timer := Timer {
        interval: 1s;
        running: button1-timeout > 0;
        triggered() => {
            if button1-timer-count > 1 {
                button1-timer-count -= 1;
            } else {
                timeout-clicked1();
                clicked1();
            }
        }
    }

    in-out property <int> button2-timer-count: button2-timeout;
    button2-timer := Timer {
        interval: 1s;
        running: button2-timeout > 0;
        triggered() => {
            if button2-timer-count > 1 {
                button2-timer-count -= 1;
            } else {
                timeout-clicked2();
                clicked2();
            }
        }
    }

    spacing: 4px;
    VerticalLayout {
        function weight-display() -> string {
            if AppState.spool-staging-state != SpoolStagingState.Empty && AppState.spool-staging-info.spool-record.weight-core != 0 {
                return "\{AppState.spool-scale-weight - AppState.spool-staging-info.spool-record.weight-core}g / \{AppState.spool-scale-weight}g";
            } else {
                return "\{AppState.spool-scale-weight}g";
            }
        }
        spacing: AppConsts.trays-spacing;
        if AppState.spool-scale-state == SpoolScaleState.Loaded || AppState.spool-scale-state == SpoolScaleState.Disconnected || AppState.spool-scale-state == SpoolScaleState.Uncalibrated || AppState.spool-scale-state == SpoolScaleState.Connected: 
           scale := Rectangle {
            text-border-timer := Timer {
                property <int> counter: 20;
                property <length> text-border-width: 1px;
                interval: 0.3s;
                running: AppState.spool-scale-flash == true;
                triggered() => {
                    if text-border-width == 1px {
                        text-border-width = 4px;
                    } else {
                        text-border-width = 1px;
                    }
                    counter = counter - 1;
                    if counter == 0 {
                        AppState.spool-scale-flash = false;
                        AppState.spool-scale-state = AppState.spool-scale-after-flash-state;
                        AppState.spool-scale-after-flash-state = SpoolScaleState.Unknown;
                        counter = 20;
                        text-border-width = 1px;
                    }
                }
            }

            height: 30px;
            border-color: black;
            border-width: text-border-timer.text-border-width;
            background: AppState.spool-scale-state == SpoolScaleState.Disconnected || AppState.spool-scale-state == SpoolScaleState.Uncalibrated ? orangered : AppState.spool-scale-state == SpoolScaleState.Connected ? lightgreen : AppState.spool-scale-state == SpoolScaleState.Loaded && !AppState.spool-scale-weight-stable ? yellow : lightskyblue;
            Text {
                color: Utils.contrasting_color(parent.background);
                font-size: 20px;
                text: AppState.spool-scale-state == SpoolScaleState.Disconnected ? "Scale Disconnected" : AppState.spool-scale-state == SpoolScaleState.Uncalibrated ? "Scale Not Calibrated" : AppState.spool-scale-state == SpoolScaleState.Connected ? "Scale Connected" : AppState.spool-scale-state == SpoolScaleState.Loaded ? weight-display() : "";
            }
        }

        lines-rect := Rectangle {
            background: message-type == StatusType.Success ? green.brighter(1.0) : (message-type == StatusType.Error ? red : white);
            preferred-width: 480px;
            border-width: text-border-width;
            border-color: black;
            VerticalLayout {
                alignment: center;
                for message-text in message-lines: Window {
                    preferred-height: message-text == "" ? 0px : 30px;
                    if message-text != "": Text {
                        horizontal-alignment: center;
                        font-size: 20px;
                        text: message-text;
                        color: message-color == black ? Utils.contrasting_color(lines-rect.background) : message-color;
                    }
                }
            }
        }
    }

    if button1-text != "": MyButton {
        width: button-width;
        text: button1-text + ((button1-timeout != 0) ? "\n(\{button1-timer_count})" : "");
        clicked => {
            // Note: Don't add code here since it won't run on the case of timeout triggering a press
            manual-clicked1();
            clicked1();
        }
    }

    if button2-text != "": MyButton {
        width: button-width;
        text: button2-text + ((button2-timeout != 0) ? "\n(\{button2-timer_count})" : "");
        clicked => {
            // Note: Don't add code here since it won't run on the case of timeout triggering a press
            manual-clicked2();
            clicked2();
        }
    }
}

export component Booting inherits ControlPanelBase {
    message-lines: ["Booting"];
}

// export component ConnectingToPrinter inherits ControlPanelBase {
//     message-text: "Connecting to Printer" + (AppState.available-printers.length > 1 ? "\n\n\{AppState.curr-printer}" : "");
// }

export component BootFailed inherits ControlPanelBase {
    message-lines: ["Boot Failed"];
    message-type: StatusType.Error;
    button1-text: "Reboot";
    clicked1 => {
        FrameworkBackend.reset-device();
    }
}

export component Ready inherits ControlPanelBase {
    color-timer := Timer {
        property <int> x: 100;
        property <float> h: 0;
        property <float> s: 0;
        property <float> v: 0;
        property <color> color: #ff0;
        interval: 0.2s;
        running: true;
        triggered() => {
            x = x + 3;
            x = x > 100 ? 27 : x;
            h = 360 * Math.mod(x, 50) / 50;
            s = 1;
            v = x >= 50 ? 1 - (x - 50) / 50 : 1;
            color-timer.color = hsv(h,s,v);
        }
    }

    message-color: color-timer.color;
    message-lines: [
        AppState.spool-staging-state == SpoolStagingState.Empty ? "Scanning for Tagged Spool..." : "Load Spool or Rescan Tag",
        AppState.available-printers.length > 1 ? "\{AppState.curr-printer}" : "",
        AppState.available-printers.length >= 1 && AppState.some-printer-connected ? "" : "- Connecting to Printer(s) -"
    ];
    button1-text: (AppState.spool-staging-state != SpoolStagingState.Empty) ? "Clear Staging" : "";
    button1-timeout: (AppState.spool-staging-state != SpoolStagingState.Empty) ? 60 : 0;
    clicked1() => {
        AppBackend.clear-staging();
    }
    property <bool> reset-staging-countdown: AppState.reset-staging-countdown;
    changed reset-staging-countdown => {
        if reset-staging-countdown {
            self.button1-timer-count = 60;
        }
    }
}

export component TraySelect inherits ControlPanelBase {
    message-lines: ["Press Slot to Configure"];
    // button1-text: "Clear Staging";
    button2-text: "Cancel";
    button2-timeout: 10;
    // clicked1() => {
    //     AppBackend.clear-staging();
    // }
    clicked2() => {
        AppState.control-state = ControlState.Ready;
    }
}

export component OperationBase inherits ControlPanelBase {
    message-lines: [AppState.user-message];
    button2-text: "Cancel";
}
// TODO: No need for OperationBase and Reading sharing with Encoding the Operation Base
// Need just Encoding and Reading, share maybe only the user-message, or maybe some alternative to that in form of state
// Can combing Erasing and Encoding - exactly the same
export component Encoding inherits OperationBase {
    message-type: AppState.user-message-type;
    text-border-timer := Timer {
        property <length> text-border-width: 1px;
        interval: 0.3s;
        running: true;
        triggered() => {
            if text-border-width == 1px {
                text-border-width = 4px;
            } else {
                text-border-width = 1px;
            }
        }
    }

    text-border-width: text-border-timer.text-border-width;
    button2-timeout: AppState.encode-timeout;
    timeout-clicked2 => {
        AppState.encoding-timeout();
    }
    manual-clicked2 => {
        AppState.encode-cancel();
    }
    clicked2 => {
      // called in both cases - manual and timeout
    }
}

export component Erasing inherits OperationBase {
    message-type: AppState.user-message-type;
    text-border-timer := Timer {
        property <length> text-border-width: 1px;
        interval: 0.3s;
        running: true;
        triggered() => {
            if text-border-width == 1px {
                text-border-width = 4px;
            } else {
                text-border-width = 1px;
            }
        }
    }

    text-border-width: text-border-timer.text-border-width;
    button2-timeout: AppState.erase-timeout;
    timeout-clicked2 => {
        AppState.erasing-timeout();
    }
    manual-clicked2 => {
        AppState.erasing-cancel();
    }
    clicked2 => {
      // called in both cases - manual and timeout
    }
}

export component Reading inherits OperationBase {
    clicked2 => {
    }
}

export component PostAction inherits ControlPanelBase {
    message-lines: [AppState.user-message];
    message-type: AppState.user-message-type;
    button1-text: "Ok";
    button1-timeout: 10;
    clicked1 => {
        AppState.control-state = ControlState.Ready;
        AppState.stop-highlight-tray();
    }
}

export component ControlPanel inherits HorizontalLayout {
    callback clicked-ota;
    in property <length> staging-section-width;
    in property <length> button-width;
    padding-top: 5px;
    spacing: AppConsts.trays-spacing;
    staging := SpoolStaging {
        clicked-ota => {
            root.clicked-ota();
        }
        width: staging-section-width;
    }

    if AppState.control-state == ControlState.Booting: Booting {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.BootFailed: BootFailed {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.Ready: Ready {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.TraySelect: TraySelect {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.Encoding: Encoding {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.Erasing: Erasing {
        button-width: button-width;
    }

    if AppState.control-state == ControlState.Reading: Reading {
        button-width: button-width;
    }
    if AppState.control-state == ControlState.PostAction: PostAction {
        button-width: button-width;
    }

    trays-timer := Timer {
        interval: 0.3s;
        running: AppState.control-state == ControlState.TraySelect;
        changed running => {
            AppState.highlight-trays = false;
            AppState.highlight-staging = false;
        }
        triggered() => {
            if AppState.control-state == ControlState.TraySelect {
                AppState.highlight-trays = !AppState.highlight-trays;
            }
        }
    }

    single-tray-timer := Timer {
        interval: 0.3s;
        running: AppState.highlight-tray != -1;
        triggered() => {
            AppState.highlight-tray-counter = AppState.highlight-tray-counter - 1;
            AppState.highlight-tray-flash = Math.mod(AppState.highlight-tray-counter, 2) == 1;
            if AppState.highlight-tray-counter == 0 {
                AppState.stop-highlight-tray();
            }
        }
    }

    staging-to-tray-timer := Timer {
        interval: 0.1s;
        running: AppState.staging-to-tray != -1;
        triggered() => {
            AppBackend.set-staging-to-tray(AppState.staging-to-tray);
            AppState.staging-to-tray = -1;
        }
    }
}
