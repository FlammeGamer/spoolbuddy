import { Utils } from "utils.slint";
import { AppConsts, AppState, ControlState, SpoolScaleState, AppBackend, UiTray, UiFilamentState, UiTrayState } from "app.slint";
import { MyText } from "framework/widgets.slint";

/////////////////////////////////////////////

component AmsButton inherits Window {
    in property <int> ams-id;
    in property <bool> active;
    in property <[UiTray]> trays-state;
    horizontal-stretch: ams-id <= 3 ? 4 : 1;

    function slot-with-spool(tray: UiTray) -> bool {
        return tray.spool-state == UiTrayState.Ready || tray.spool-state == UiTrayState.Loading || tray.spool-state == UiTrayState.Loaded || tray.spool-state == UiTrayState.Unloading;
    }
    function slot-with-known-color(tray: UiTray) -> bool {
        return tray.filament.state != UiFilamentState.Unknown;
    }

    if ams-id != -1: ams-selector := Rectangle {
        height: parent.height;
        width: parent.width;
        // background: active ? @linear-gradient(180deg, #09009B 0%, #0000CA 39%, #001dff 100%) : white;
        background: active ? #bbb : white;
        border-width: active ? 4px : 1px;
        border-color: #001dff;
        HorizontalLayout {
            padding-top: 6px + (active ? 0px : 3px);
            padding-bottom: 0px + (active ? 0px : 3px);
            padding-left: 6px;
            padding-right: 6px;
            spacing: 3px + (active ? 0px : 3px);
            for tray-id in ams-id <= 3 ? [0, 1, 2, 3] : [0]: block := Rectangle {
                horizontal-stretch: 0;
                property <bool> used-in-print: trays-state[AppState.get_tray_index(ams-id,tray-id)].used-in-print;
                property <bool> slot-is-with-spool: slot-with-spool(trays-state[AppState.get_tray_index(ams-id,tray-id)]);
                property <bool> slot-is-with-known-color: slot-with-known-color(trays-state[AppState.get_tray_index(ams-id,tray-id)]);
                property <bool> slot-is-loaded: trays-state[AppState.get_tray_index(ams-id,tray-id)].spool-state == UiTrayState.Loaded;
                height: parent.height - parent.padding-top - parent.padding-bottom - 3px * 2;
                background: /*slot-is-with-spool &&*/ slot-is-with-known-color ? trays-state[AppState.get_tray_index(ams-id,tray-id)].filament.color : AppConsts.no-color;

                if !slot-is-with-spool: special-cases-circle := Rectangle {
                    height: Math.min(parent.height, parent.width) - 4px;
                    width: self.height;
                    border-color: black;
                    border-width: 1px;
                    background: white;
                    border-radius: Math.min(self.width, self.height) / 2;
                }

                normal-border := Rectangle {
                    height: parent.height;
                    width: parent.width;
                    border-color: black;
                    border-width: 1px;
                    MyText {
                        // The "✓" is hidden for all texts to have something, otherwise the width of the rectangles become different for some reason
                        // only thing I didn't try to fix that with empty or space is centering the text which already looks centered
                        // and so the "✓" won't show, use transparent color
                        text: !slot-is-with-spool ? "−" : !slot-is-with-known-color ? "?" : "✓";
                        color: self.text == "✓" ? #00000000 : !slot-is-with-spool ? black : slot-is-with-known-color ? Utils.contrasting_color(block.background) : white;
                    }
                }

                if used-in-print: in-use-border := Rectangle {
                    x: -2px;
                    y: -2px;
                    width: parent.width + 4px;
                    height: parent.height + 4px;
                    border-width: 2px;
                    border-color: black;
                }
                if slot-is-loaded: Image {
                    source: @image-url("./img/extruder.png");
                    colorize: Utils.contrasting_color(block.background);
                }
            }
        }

        area := TouchArea {
            width: parent.width;
            height: parent.height;
            clicked => {
                AppState.curr-ams-id = ams-id;
            }
        }
    }
}

component Spool inherits Rectangle {
    callback clicked;
    in-out property <UiTray> tray-state;

    background: tray-state.filament.state == UiFilamentState.Unknown ? AppConsts.no-color : tray-state.filament.color;
    VerticalLayout {
        padding-left: (self.width - circle.width) / 2;
        padding-right: self.padding-left;
        padding-top: 5px;
        padding-bottom: self.padding-top + 2px;
        spacing: 4px;

        circle := Rectangle {
            width: parent.width - 8px;
            height: self.width;
            background: tray-state.spool-state == UiTrayState.Unknown || tray-state.spool-state == UiTrayState.Empty || tray-state.spool-state == UiTrayState.Spool || tray-state.spool-state == UiTrayState.Reading || tray-state.filament.state == UiFilamentState.Unknown ? #fff : tray-state.filament.color;
            border-radius: root.width / 2;
            border-color: Utils.contrasting_color(root.background);
            border-width: area.pressed ? 4px : 2px;
            property <string> default-big-text: tray-state.spool-state == UiTrayState.Unknown ? "?" : tray-state.spool-state == UiTrayState.Empty ? "−" : tray-state.spool-state == UiTrayState.Spool ? "↺" : tray-state.spool-state == UiTrayState.Reading ? "↻" : "✓";
            property <bool> display-weight: default-big-text == "✓" && tray-state.weight-display != "";

            if !display-weight: Text {
                text: default-big-text;
                color: Utils.contrasting_color(parent.background);
                font-size: 60px;
            }

            if display-weight: MyText {
                text: tray-state.weight-display;
                color: Utils.contrasting_color(parent.background);
            }

            if tray-state.spool-state == UiTrayState.Loaded: Image {
                y: circle.height / 2 + 15px;
                source: @image-url("./img/extruder.png");
                colorize: Utils.contrasting_color(parent.background);
            }
        }

        // Text below circle

        material := Text {
            height: 18px;
            horizontal-alignment: center;
            font-size: 20px;
            text: tray-state.filament.state == UiFilamentState.Unknown ? "???" : tray-state.filament.material;
            color: Utils.contrasting_color(root.background);
        }

        k-value := Text {
            height: 20px;
            horizontal-alignment: center;
            font-size: 20px;
            text: tray-state.filament.state == UiFilamentState.Unknown ? "" : "K " + tray-state.k;
            color: Utils.contrasting_color(root.background);
        }
    }

    tray-border := Rectangle {
        // when to set border thick
        border-width: area.pressed || (AppState.control-state == ControlState.TraySelect) || (AppState.highlight-tray == tray-state.id && AppState.highlight-tray-flash) ? 4px : 1px;
        border-color: AppState.control-state == ControlState.TraySelect ? (AppState.highlight-trays ? black : white) : self.border-width == 1px ? black : Utils.contrasting_color(root.background);
    }

    if tray-state.tagged: tag := Rectangle {
        x: 15px;
        y: 2px;
        width: parent.width - 2 * self.x;
        height: 30px;
        background: lightgreen.darker(0.1);
        border-radius: 15px;
        border-color: darkgreen.darker(0.5);
        border-width: 1px;
        MyText {
            text: tray-state.spool-rec-id;
            color: black;
        }
    }

    if tray-state.used-in-print: Rectangle {
        x: -3px;
        y: -3px;
        width: parent.width + 6px;
        height: parent.height + 6px;
        border-color: black;
        border-width: 3px;
    }

    area := TouchArea {
        // touch area is shifted (by 20px) from the top to not accidentally press AMS and hit a tray
        y: parent.y + 20px;
        width: parent.width;
        height: parent.height - 20px;
        clicked => {
            root.clicked();
        }
    }
}

component Tray inherits Window {
    in-out property <UiTray> tray-state;
    callback clicked();
    // Not clear why, but VerticalLayout (with single item inside?) stretches it to the correct height
    VerticalLayout {
        padding: 0px;
        spacing: 4px;
        Spool {
            tray-state: tray_state;
            clicked => {
                root.clicked();
            }
            width: (480px - 4 * AppConsts.trays-spacing) / 5;
        }
    }
}

export component Trays {
    callback title-clicked;
    in-out property <[int]> tray_numbers;
    in-out property <[UiTray]> trays-state;
    in property <string> title: "External";
    in property <bool> include-paging-left: false;
    in property <bool> include-paging-right: false;
    in property <bool> is_ams: false;

    VerticalLayout {
        spacing: AppConsts.trays-spacing;
        title := HorizontalLayout {
            height: 50px;
            spacing: 2px;

            Rectangle {
                background: @linear-gradient(180deg, #09009B 0%, #0000CA 39%, #001dff 100%);
                if !is_ams: Text {
                    text: root.title;
                    font-size: 20px;
                    color: white;
                }

                Rectangle {
                    border-width: 1px;
                    border-color: black;
                }

                if is_ams: HorizontalLayout {
                    for ams-id in AppState.ams-exists: AmsButton {
                        height: parent.height;
                        // width: self.height;
                        ams-id: ams-id;
                        trays-state: trays-state;
                        active: AppState.curr-ams-id == ams-id;
                    }
                }
                if !is_ams: TouchArea {
                    width: parent.width;
                    height: parent.height;
                    clicked => {
                        root.title-clicked()
                    }
                }
            }
        }

        trays := HorizontalLayout {
            alignment: center;
            spacing: AppConsts.trays-spacing;
            padding-left: 0px;
            padding-right: 0px;
            width: is_ams ? 480px - (480px - 4 * AppConsts.trays-spacing) / 5 - AppConsts.trays-spacing : (480px - 4 * AppConsts.trays-spacing) / 5;
            for index in tray_numbers: Tray {
                // visible: AppState.selected-tray-index == -1 || AppState.selected-tray-index == index;
                tray-state: trays-state[index];
                clicked() => { // ? TODO: Think if to move into the tray component
                    if AppState.control-state == ControlState.TraySelect {
                        AppBackend.set-staging-to-tray(trays-state[index].id);
                    } else if (AppState.control-state == ControlState.Ready || AppState.control-state == ControlState.PostAction) {
                        AppState.tray-selected(index);
                    }
                }
            }
        }
    }
}
